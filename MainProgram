import tkinter as tk
from tkinter.colorchooser import askcolor


class PixelDrawer:
    def __init__(self, root=tk.Tk()):
        self.root = root
        self.root.title("PixelPainter")
        self.size = 25  # XM
        self.root.geometry("500x517")
        self.color = "black"
        self.secondary_color = "white"
        self.grid_color = "light gray"
        self.grid = []  # tracks gridlines
        self.grid_shown = True
        self.symmetry = None
        self.font = ["times", 10, "normal"]
        self.btn_relief = "raised"
        self.btn_bd = 1
        self.filled_coords = {}  # helps prevent overload

        # button area
        self.PALETTE = tk.Frame(self.root)
        self.PALETTE.pack(fill=tk.BOTH, expand=True)

        # color selection
        self.colorFrame = tk.LabelFrame(
            self.PALETTE, labelanchor="n", text="Colors", bd=0
        )
        self.colorFrame.pack(side=tk.LEFT, anchor="w")

        self.defaultColors = tk.Frame(self.colorFrame)
        self.defaultColors.pack(side=tk.TOP)

        self.savedColors = tk.Frame(self.colorFrame)
        self.savedColors.pack(side=tk.TOP)

        # grid size selection
        self.sizeFrame = tk.LabelFrame(
            self.PALETTE, labelanchor="n", text="Grid Size and View", bd=0
        )
        self.sizeFrame.pack(side=tk.LEFT, anchor="w")

        self.gridFrame = tk.LabelFrame(
            self.PALETTE, labelanchor="n", text="Grid View", bd=0
        )
        self.gridFrame.pack(side=tk.LEFT, anchor="w")

        # symmetry selection
        self.symmetryFrame = tk.LabelFrame(
            self.PALETTE, labelanchor="n", text="Symmetry", bd=0
        )
        self.symmetryFrame.pack(side=tk.LEFT, anchor="w")

        # clear or fill canvas
        self.clearFillFrame = tk.LabelFrame(
            self.PALETTE, labelanchor="n", text="Clear/Fill", bd=0
        )
        self.clearFillFrame.pack(side=tk.LEFT, anchor="w")

        # painting surface
        self.easel = tk.Frame(self.root)
        self.easel.pack(fill=tk.BOTH, expand=True)
        self.canvas = tk.Canvas(self.easel, bg="white", width=400, height=800)
        self.canvas.pack(fill=tk.BOTH, expand=True)

        def color_choose(color):
            if color is None:
                self.color = askcolor(color=self.color)[1]
                color_selecter.config(bg=self.color)
                last_used_color.config(bg=self.color)
            else:
                self.color = color
                last_used_color.config(bg=color_selecter.cget("bg"))
                color_selecter.config(bg=self.color)

        def secondary_color_choose(event):
            if event.widget.cget("bg") is "SystemButtonFace":
                self.secondary_color = askcolor(color=self.color)[1]
            else:
                self.secondary_color = event.widget.cget("bg")

        def clearAll(fill_color):
            self.canvas.delete("all")
            if fill_color is "white":
                self.canvas.config(bg="white")
                self.grid_color = "light gray"
            else:
                self.canvas.config(bg=self.color)
                self.grid_color = self.color
            make_grid(self.size, self.grid_color)

        def set_symmetry(sym_type):
            if sym_type is None:
                self.canvas.bind("<Button-1>", pixel_placement)
            self.symmetry = sym_type

        def pixel_placement(event):
            def get_coords():
                x = self.size * int(event.x / self.size)
                y = self.size * int(event.y / self.size)
                x_sym = (
                    self.size * int(self.easel.winfo_width() / self.size)
                    - int(x / self.size) * self.size
                    - self.size
                )
                y_sym = (
                    self.size * int(self.easel.winfo_height() / self.size)
                    - int(y / self.size) * self.size
                    - self.size
                )
                return [x, y, x_sym, y_sym]

            if (
                get_coords()[0],
                get_coords()[1],
            ) in self.filled_coords and self.filled_coords[
                get_coords()[0], get_coords()[1]
            ] is self.color:
                pass  # helps prevent overload
            else:
                if self.symmetry == "horizontal":
                    get_coords()[2] = (
                        self.size * int(self.easel.winfo_width() / self.size)
                        - int(get_coords()[0] / self.size) * self.size
                        - self.size
                    )

                    self.canvas.create_rectangle(
                        get_coords()[0],
                        get_coords()[1],
                        get_coords()[0] + self.size,
                        get_coords()[1] + self.size,
                        fill=self.color,
                        outline=self.color,
                    )
                    self.canvas.create_rectangle(
                        get_coords()[2],
                        get_coords()[1],
                        get_coords()[2] + self.size,
                        get_coords()[1] + self.size,
                        fill=self.color,
                        outline=self.color,
                    )
                    self.filled_coords[get_coords()[0], get_coords()[1]] = self.color
                elif self.symmetry == "vertical":
                    get_coords()[3] = (
                        self.size * int(self.easel.winfo_height() / self.size)
                        - int(get_coords()[1] / self.size) * self.size
                        - self.size
                    )
                    self.canvas.create_rectangle(
                        get_coords()[0],
                        get_coords()[1],
                        get_coords()[0] + self.size,
                        get_coords()[1] + self.size,
                        fill=self.color,
                        outline=self.color,
                    )
                    self.canvas.create_rectangle(
                        get_coords()[0],
                        get_coords()[3],
                        get_coords()[0] + self.size,
                        get_coords()[3] + self.size,
                        fill=self.color,
                        outline=self.color,
                    )
                    self.filled_coords[get_coords()[0], get_coords()[1]] = self.color
                elif self.symmetry == "both":
                    get_coords()[2] = (
                        self.size * int(self.easel.winfo_width() / self.size)
                        - int(get_coords()[0] / self.size) * self.size
                        - self.size
                    )
                    get_coords()[3] = (
                        self.size * int(self.easel.winfo_height() / self.size)
                        - int(get_coords()[1] / self.size) * self.size
                        - self.size
                    )

                    self.canvas.create_rectangle(
                        get_coords()[0],
                        get_coords()[1],
                        get_coords()[0] + self.size,
                        get_coords()[1] + self.size,
                        fill=self.color,
                        outline=self.color,
                    )
                    self.canvas.create_rectangle(
                        get_coords()[2],
                        get_coords()[1],
                        get_coords()[2] + self.size,
                        get_coords()[1] + self.size,
                        fill=self.color,
                        outline=self.color,
                    )
                    self.canvas.create_rectangle(
                        get_coords()[0],
                        get_coords()[3],
                        get_coords()[0] + self.size,
                        get_coords()[3] + self.size,
                        fill=self.color,
                        outline=self.color,
                    )
                    self.canvas.create_rectangle(
                        get_coords()[2],
                        get_coords()[3],
                        get_coords()[2] + self.size,
                        get_coords()[3] + self.size,
                        fill=self.color,
                        outline=self.color,
                    )

                    self.filled_coords[get_coords()[0], get_coords()[1]] = self.color
                else:
                    self.canvas.create_rectangle(
                        get_coords()[0],
                        get_coords()[1],
                        get_coords()[0] + self.size,
                        get_coords()[1] + self.size,
                        fill=self.color,
                        outline=self.color,
                    )
                    self.filled_coords[get_coords()[0], get_coords()[1]] = self.color

        def pixel_placement_color2(event):
            x = self.size * int(event.x / self.size)
            y = self.size * int(event.y / self.size)

            if (x, y) in self.filled_coords and self.filled_coords[x, y] is not None:
                pass  # helps prevent overload
            else:  # test for symmetry type
                if self.symmetry == "horizontal":
                    x_sym = (
                        self.size * int(self.easel.winfo_width() / self.size)
                        - int(x / self.size) * self.size
                        - self.size
                    )

                    self.canvas.create_rectangle(
                        x,
                        y,
                        x + self.size,
                        y + self.size,
                        fill=self.secondary_color,
                        outline=self.secondary_color,
                    )
                    self.canvas.create_rectangle(
                        x_sym,
                        y,
                        x_sym + self.size,
                        y + self.size,
                        fill=self.secondary_color,
                        outline=self.secondary_color,
                    )
                    self.filled_coords[x, y] = self.secondary_color
                elif self.symmetry == "vertical":
                    y_sym = (
                        self.size * int(self.easel.winfo_height() / self.size)
                        - int(y / self.size) * self.size
                        - self.size
                    )
                    self.canvas.create_rectangle(
                        x,
                        y,
                        x + self.size,
                        y + self.size,
                        fill=self.secondary_color,
                        outline=self.secondary_color,
                    )
                    self.canvas.create_rectangle(
                        x,
                        y_sym,
                        x + self.size,
                        y_sym + self.size,
                        fill=self.secondary_color,
                        outline=self.secondary_color,
                    )
                    self.filled_coords[x, y] = self.secondary_color
                elif self.symmetry == "both":
                    x_sym = (
                        self.size * int(self.easel.winfo_width() / self.size)
                        - int(x / self.size) * self.size
                        - self.size
                    )
                    y_sym = (
                        self.size * int(self.easel.winfo_height() / self.size)
                        - int(y / self.size) * self.size
                        - self.size
                    )

                    self.canvas.create_rectangle(
                        x,
                        y,
                        x + self.size,
                        y + self.size,
                        fill=self.secondary_color,
                        outline=self.secondary_color,
                    )
                    self.canvas.create_rectangle(
                        x_sym,
                        y,
                        x_sym + self.size,
                        y + self.size,
                        fill=self.secondary_color,
                        outline=self.secondary_color,
                    )
                    self.canvas.create_rectangle(
                        x,
                        y_sym,
                        x + self.size,
                        y_sym + self.size,
                        fill=self.secondary_color,
                        outline=self.secondary_color,
                    )
                    self.canvas.create_rectangle(
                        x_sym,
                        y_sym,
                        x_sym + self.size,
                        y_sym + self.size,
                        fill=self.secondary_color,
                        outline=self.secondary_color,
                    )

                    self.filled_coords[x, y] = self.secondary_color
                else:
                    self.canvas.create_rectangle(
                        x,
                        y,
                        x + self.size,
                        y + self.size,
                        fill=self.secondary_color,
                        outline=self.secondary_color,
                    )
                    self.filled_coords[x, y] = self.secondary_color

        def get_dimensions():
            x = self.size * round(self.root.winfo_width() / self.size)
            y = self.size * round(self.root.winfo_height() / self.size)
            return x, y

        def gridSnap(*args):
            self.root.geometry(f"{get_dimensions()[0]}x{get_dimensions()[1]-8}")

        def hide_grid():
            if self.grid_shown:
                make_grid(self.size, "white")
                self.grid_shown = False
            else:
                make_grid(self.size, self.grid_color)
                self.grid_shown = True

        def make_grid(size, color):
            self.size = size
            for i in self.grid:
                self.canvas.delete(i)  # delete grid before remaking
            self.grid.clear()  # reset grid cache
            self.filled_coords.clear()
            for i in range(1, int(get_dimensions()[1] / self.size)):
                n = self.canvas.create_line(
                    0,
                    i * self.size,
                    self.root.winfo_width(),
                    i * self.size,
                    fill=color,
                )
                self.grid.append(n)
            for i in range(1, int(get_dimensions()[0] / self.size)):
                n = self.canvas.create_line(
                    i * self.size,
                    0,
                    i * self.size,
                    self.root.winfo_height(),
                    fill=color,
                )
                self.grid.append(n)
            self.easel.update()
            self.curr_grid_size = self.size
            self.grid_shown = True

        def btn_placement(list, item, span):
            return list.index(item) * span

        # colors
        colors = [
            "black",
            "red",
            "yellow",
            "blue",
            "white",
            "orange",
            "green",
            "purple",
        ]

        for color in colors:
            _ = tk.Button(
                self.defaultColors,
                width=2,
                height=1,
                relief=self.btn_relief,
                bd=self.btn_bd,
                bg=color,
                command=lambda x=color: color_choose(x),
            )
            _.grid(
                row=1,
                column=btn_placement(colors, color, 2),
                columnspan=2,
                sticky=tk.NSEW,
            )
            _.bind("<Button-3>", lambda x=_.cget("bg"): secondary_color_choose(x))
        color_selecter = tk.Button(
            self.savedColors,
            width=11,
            height=1,
            relief=self.btn_relief,
            bd=self.btn_bd,
            text="Current Color",
            bg="black",
            command=lambda: color_choose(None),
        )
        color_selecter.pack(side=tk.RIGHT, fill=tk.X, padx=(0, 2))

        last_used_color = tk.Button(
            self.savedColors,
            width=12,
            height=1,
            relief=self.btn_relief,
            bd=self.btn_bd,
            bg="white",
            text="Last Color",
        )
        last_used_color.bind(
            "<Button-1>", lambda x=1: color_choose(last_used_color.cget("bg"))
        )
        last_used_color.pack(side=tk.LEFT, fill=tk.X)

        # size buttons
        sizes = [
            ("S", 10, 0, 0),
            ("XS", 5, 1, 0),
            ("M", 20, 0, 1),
            ("XM", 25, 1, 1),
            ("L", 50, 0, 2),
            ("XL", 100, 1, 2),
        ]
        for size in sizes:
            v = tk.Button(
                self.sizeFrame,
                text=size[0],
                width=4,
                height=1,
                relief=self.btn_relief,
                bd=self.btn_bd,
                command=lambda x=size[1]: make_grid(x, self.grid_color),
            )
            v.grid(row=size[2], column=size[3], sticky=tk.NSEW)
        show_hide_grid = tk.Button(
            self.sizeFrame,
            width=3,
            height=1,
            relief=self.btn_relief,
            bd=self.btn_bd,
            text="#",
            font=["times", 14, "normal"],
            command=hide_grid,
        )
        show_hide_grid.grid(
            row=0,
            column=3,
            rowspan=2,
            sticky=tk.NSEW,
        )

        no_sym = tk.Button(
            self.symmetryFrame,
            width=6,
            height=1,
            relief=self.btn_relief,
            bd=self.btn_bd,
            text="⨞",
            font=self.font,
            command=lambda: self.easel.bind("<Button-1>", set_symmetry(None)),
        )
        no_sym.grid(row=0, column=0, sticky=tk.NSEW)

        hor_sym = tk.Button(
            self.symmetryFrame,
            width=6,
            height=1,
            relief=self.btn_relief,
            bd=self.btn_bd,
            text="⨝",
            font=self.font,
            command=lambda: set_symmetry("horizontal"),
        )
        hor_sym.grid(row=0, column=1, sticky=tk.NSEW)

        vert_sym = tk.Button(
            self.symmetryFrame,
            width=6,
            height=1,
            relief=self.btn_relief,
            bd=self.btn_bd,
            text="⧖",
            font=self.font,
            command=lambda: set_symmetry("vertical"),
        )
        vert_sym.grid(row=1, column=0, sticky=tk.NSEW)

        both_sym = tk.Button(
            self.symmetryFrame,
            width=6,
            height=1,
            relief=self.btn_relief,
            bd=self.btn_bd,
            text="☒",
            font=self.font,
            command=lambda: set_symmetry("both"),
        )
        both_sym.grid(row=1, column=1, sticky=tk.NSEW)

        clear_all = tk.Button(
            self.clearFillFrame,
            width=3,
            height=1,
            relief=self.btn_relief,
            bd=self.btn_bd,
            text="◯",
            font=self.font,
            command=lambda: clearAll("white"),
        )
        clear_all.pack(side=tk.TOP, fill=tk.BOTH)

        fill_all = tk.Button(
            self.clearFillFrame,
            width=3,
            height=1,
            relief=self.btn_relief,
            bd=self.btn_bd,
            text="⬤",
            font=self.font,
            command=lambda: clearAll(self.color),
        )
        fill_all.pack(side=tk.BOTTOM, fill=tk.BOTH)

        self.canvas.bind(
            "<Configure>", lambda x=1: make_grid(self.size, self.grid_color)
        )
        self.root.bind("<ButtonRelease-1>", lambda x=1: gridSnap(x))
        self.canvas.bind("<Button-1>", pixel_placement)
        self.canvas.bind("<B1-Motion>", pixel_placement)
        self.canvas.bind("<Button-3>", pixel_placement_color2)
        self.canvas.bind("<B3-Motion>", pixel_placement_color2)
        self.canvas.bind("<Button-2>", pixel_placement_color2)
        self.canvas.bind("<B2-Motion>", pixel_placement_color2)

        self.root.mainloop()


if __name__ == "__main__":
    PixelDrawer()
